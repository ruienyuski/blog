[{"title":"dataset","url":"/blog/2020/10/23/dataset/","content":"<p><code>HTML</code> 在設定 <code>data-*</code> 會遇到的情況如下</p>\n<a id=\"more\"></a>\n<p>以這個<a href=\"https://codepen.io/HexSchool_yuko/pen/wvWoVJG\">刪除 todo 項目範例</a>來說<br>在 JS 第 10 行的 <code>data-num</code> 中有設定刪除</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;#&quot;</span> data-num=<span class=\"string\">&#x27;+ i +&#x27;</span>&gt;&lt;span&gt;刪除&lt;span&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>但是卻發生只會刪除第一項的錯誤狀況<br>這是因為他點的是 <code>&lt;a&gt;</code> 裡面的 <code>&lt;span&gt;</code>，也就是 <code>list.addEventListener</code> 裡面的 <code>console</code> 顯示 <code>SPAN</code><br>在 <code>&lt;span&gt;</code> 上並沒有設定 <code>data-num</code> 因此會出錯<br>要避免這個錯誤就需要把 <code>data-num=&#39;+ i +&#39;</code> 放到 <code>&lt;span&gt;</code><br>或者是 <code>&lt;a&gt;</code> 和 <code>&lt;span&gt;</code> 一起加上 <code>data-num</code> 就不會出錯</p>\n<p>另外也有人會在 <code>&lt;a&gt;</code> 加上 <code>/</code> 如第 20 行的</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;a href=<span class=\"string\">&quot;#&quot;</span> data-num=<span class=\"string\">&#x27;+ i +&#x27;</span>/&gt;刪除&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>出錯是因為斜線放到後面是代表該標籤自帶結尾標籤<br><code>&lt;a&gt;</code> 的結束標籤應是後方的 </a> ，加上斜線會導致取值錯誤，只會刪除第一筆資料</p>\n<p>而且 <code>dataset</code>也可用 <code>[]</code>來讀取數值</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">data.splice(e.target.dataset[<span class=\"string\">&#x27;num&#x27;</span>], 1);</span><br></pre></td></tr></table></figure>\n<p>如同 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/HTMLElement/dataset\">MDN 文件</a>裡面的「存取數值」」提到<br>「 資料屬性也可以經由物件屬性 <code>[]</code> 語法的方式設定或讀取，如 <code>element.dataset[keyname]</code>。」</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"createElement","url":"/blog/2020/09/16/create-element/","content":"<p><code>createElement</code> 與 <code>innerHTML</code> 都是插入 <code>HTML</code> 標籤的兩種方法<br>這邊整理 <code>createElement</code> 內容</p>\n<a id=\"more\"></a>\n<h2 id=\"createElement-寫法\"><a href=\"#createElement-寫法\" class=\"headerlink\" title=\"createElement 寫法\"></a>createElement 寫法</h2><p>先使用 <code>createElement</code> 建立元素，以下將內容放到 <a href=\"https://codepen.io/HexSchool_yuko/pen/poyZxEX\">Codepen</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var li = document.createElement(<span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\">li.textContent = <span class=\"string\">&#x27;item 1&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>再使用 <code>appendChild</code> 用新增子節點的方式去新增</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">document.querySelector(<span class=\"string\">&#x27;ul&#x27;</span>).appendChild(li);</span><br></pre></td></tr></table></figure>\n<p>以上可參考 JS 第 1-3 行註解內容<br>若要大量增加，可使用 <code>for 迴圈</code>，可參考 JS 第 5-24 行內容</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    student: <span class=\"string\">&#x27;joe&#x27;</span>,</span><br><span class=\"line\">    age:10,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    student: <span class=\"string\">&#x27;bill&#x27;</span>,</span><br><span class=\"line\">    age:9,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    student: <span class=\"string\">&#x27;kevin&#x27;</span>,</span><br><span class=\"line\">    age:11,</span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">];</span><br><span class=\"line\">var len = data.length;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=0; i&lt;len; i++) &#123;</span><br><span class=\"line\">  var li = document.createElement(<span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\">  li.textContent = data[i].student;</span><br><span class=\"line\">  document.querySelector(<span class=\"string\">&#x27;ul&#x27;</span>).appendChild(li);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"appendChild-放-for-迴圈裡面\"><a href=\"#appendChild-放-for-迴圈裡面\" class=\"headerlink\" title=\"appendChild 放 for 迴圈裡面\"></a>appendChild 放 for 迴圈裡面</h2><p><code>appendChild</code> 放 <code>for 迴圈</code> 裡面是每個產生一個元素，就將該元素寫入到對應位置。<br>但放外面的話，他就只會放最後一筆資料到裡頭。</p>\n<h2 id=\"迴圈內宣告-createElement\"><a href=\"#迴圈內宣告-createElement\" class=\"headerlink\" title=\"迴圈內宣告 createElement\"></a>迴圈內宣告 createElement</h2><p>迴圈內宣告 <code>createElement</code> 代表每跑一次迴圈都會宣告並產生一個新的 <code>li</code> 元素<br>把 <code>document.createElement(&quot;li&quot;)</code> 放在迴圈外<br>他會導致每次迴圈在執行，都會替換「同一個」之前宣告好的 <code>li</code> 文字內容<br>也就是每次新增都是取代前一個<br>所以要能產生多筆內容，建議把他放在迴圈內</p>\n<h2 id=\"appendChild-放在迴圈內\"><a href=\"#appendChild-放在迴圈內\" class=\"headerlink\" title=\"appendChild 放在迴圈內\"></a>appendChild 放在迴圈內</h2><p><code>appendChild</code> 它的特性是會在後面做累加動作<br>放在迴圈外，他就只會放最後一筆資料到裡頭</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"event.target","url":"/blog/2020/10/30/event-target/","content":"<p><code>event.target</code> 相關內容整理</p>\n<a id=\"more\"></a>\n<h2 id=\"event-簡介\"><a href=\"#event-簡介\" class=\"headerlink\" title=\"event 簡介\"></a>event 簡介</h2><p><code>function</code> 小括號裡面帶入隨意參數 <code>a</code>，若用按鈕觸發這個 <code>function</code> 則會取得<br><code>MouseEvent</code>，如下圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-1.png\"></p>\n<p><code>MouseEvent</code> 點開後可看到各種資訊，像是 <code>clineX</code>、<code>clineY</code>，如下圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-2.png\"></p>\n<h2 id=\"event-target\"><a href=\"#event-target\" class=\"headerlink\" title=\"event.target\"></a>event.target</h2><p>往下會看到 <code>target</code> 的屬性，裡面有 <code>innerHTML</code> 和 <code>innerText</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-3.png\"><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-4.png\"></p>\n<p>可以將 <code>function</code> 裡面用  <code>a.target.innerHTML = &#39;BTN&#39;</code> 來變更按鈕上的文字<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-5.png\"></p>\n<p>若是在 <code>button</code> 裡面增加 <code>value</code> 屬性，使用 <code>event.target.value</code> 就可以取得其值<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-6.png\"></p>\n<p>但剛取名的參數建議改用 <code>e</code> 或是 <code>event</code> 可以較明白這個參數是為了取得 <code>event</code> 事件內容</p>\n<h2 id=\"不用參數-e-與直接使用-event-差異\"><a href=\"#不用參數-e-與直接使用-event-差異\" class=\"headerlink\" title=\"不用參數 e 與直接使用 event 差異\"></a>不用參數 e 與直接使用 event 差異</h2><p>若不用參數也是可以直接使用 <code>event</code> ，如圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201030_event_target/event_target-6.png\"></p>\n<p>但也會因為如此可讀性就較差，因為明明沒宣告任何值，就突然冒出一個可用的 <code>event</code> 值，閱讀直覺相對來說就比較差。</p>\n<p>所以基於可讀性來說，建議還是要自訂傳入參數名稱</p>\n<h2 id=\"event-target-與-this-差異\"><a href=\"#event-target-與-this-差異\" class=\"headerlink\" title=\"event.target 與 this 差異\"></a>event.target 與 this 差異</h2><p>而另外 <code>event.target</code> 也與 <code>this</code> 用法也有所差異</p>\n<blockquote>\n<p>event.target 指的是當下滑鼠事件的目標<br>this 會指向綁定這個事件的元素</p>\n</blockquote>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"JS 獲取子節點、父節點和兄弟節點的幾種方式","url":"/blog/2020/10/27/JS-%E7%8D%B2%E5%8F%96%E5%AD%90%E7%AF%80%E9%BB%9E%E3%80%81%E7%88%B6%E7%AF%80%E9%BB%9E%E5%92%8C%E5%85%84%E5%BC%9F%E7%AF%80%E9%BB%9E%E7%9A%84%E5%B9%BE%E7%A8%AE%E6%96%B9%E5%BC%8F/","content":"<p>整理取得相關節點的方式</p>\n<a id=\"more\"></a>\n<h2 id=\"獲取子節點的方式\"><a href=\"#獲取子節點的方式\" class=\"headerlink\" title=\"獲取子節點的方式\"></a>獲取子節點的方式</h2><h3 id=\"Node-childNodes-獲取子節點\"><a href=\"#Node-childNodes-獲取子節點\" class=\"headerlink\" title=\"Node.childNodes 獲取子節點\"></a>Node.childNodes 獲取子節點</h3><p>使用 <code>Node.childNodes</code> 獲取子節點的時候，<code>Node.childNodes</code> 回傳的是子節點的集合，是一個數組的格式。他會把換行和空格或是註解也當成是節點信息。<br>可參考 Kuro 的文章裡面的 <a href=\"https://ithelp.ithome.com.tw/articles/10191765\">Node.childNodes</a><br>文章中也提到「可以透過 <code>Node.hasChildNodes()</code> 來檢查某個 <code>DOM</code> 節點是否有子節點」</p>\n<h3 id=\"Node-firstChild-獲取第一個子節點\"><a href=\"#Node-firstChild-獲取第一個子節點\" class=\"headerlink\" title=\"Node.firstChild 獲取第一個子節點\"></a>Node.firstChild 獲取第一個子節點</h3><p><code>Node.firstChild</code> 來獲取第一個子元素，但是在有些情況下我們打印的時候會顯示 <code>undefined</code>，這是因為 <code>Node.firstChild</code> 和 <code>Node.childNodes</code> 是一樣的，在瀏覽器解析的時候會把他當換行和空格一起解析，其實獲取的是第一個子節點，只是這個子節點是一個換行或者是一個空格而已。</p>\n<h3 id=\"ParentNode-firstElementChild-獲取第一個子節點\"><a href=\"#ParentNode-firstElementChild-獲取第一個子節點\" class=\"headerlink\" title=\"ParentNode.firstElementChild 獲取第一個子節點\"></a>ParentNode.firstElementChild 獲取第一個子節點</h3><p><code>ParentNode.firstElementChild</code> 介面會回傳 <code>ParentNode</code> 的第一個子元素，如果該節點沒有子節點則回傳 <code>null</code>。這就沒有 <code>Node.firstChild</code> 的那種情況，他並不會匹配換行和空格信息。</p>\n<h3 id=\"Node-lastChild-獲取最後一個子節點\"><a href=\"#Node-lastChild-獲取最後一個子節點\" class=\"headerlink\" title=\"Node.lastChild 獲取最後一個子節點\"></a>Node.lastChild 獲取最後一個子節點</h3><p><code>Node.lastChild</code> 獲取最後一個子節點的方式其實和 <code>Node.firstChild</code> 是類似的。同樣的 <code>ParentNode.lastElementChild</code> 和 <code>ParentNode.firstElementChild</code> 也是一樣的。他並不會匹配換行和空格信息。</p>\n<h2 id=\"獲取父節點的方式\"><a href=\"#獲取父節點的方式\" class=\"headerlink\" title=\"獲取父節點的方式\"></a>獲取父節點的方式</h2><h3 id=\"Node-parentNode-獲取父節點\"><a href=\"#Node-parentNode-獲取父節點\" class=\"headerlink\" title=\"Node.parentNode 獲取父節點\"></a>Node.parentNode 獲取父節點</h3><p>透過 <code>Node.parentNode</code> 可以用來取得父元素，回傳值可能會是一個元素節點 (<code>Element node</code>)、根節點 (<code>Document node</code>) 或 <code>DocumentFragment</code> 節點。</p>\n<h3 id=\"Node-parentElement\"><a href=\"#Node-parentElement\" class=\"headerlink\" title=\"Node.parentElement\"></a>Node.parentElement</h3><p>如同 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentElement\">MDN 文件</a>提到：<br>「回傳當前節點的父元素節點，如果該元素沒有父節點，或者父節點不是一個 <code>DOM</code> 元素，則回傳 <code>null</code>。」</p>\n<h3 id=\"HTMLElement-offsetParent-獲取所有父節點\"><a href=\"#HTMLElement-offsetParent-獲取所有父節點\" class=\"headerlink\" title=\"HTMLElement.offsetParent 獲取所有父節點\"></a>HTMLElement.offsetParent 獲取所有父節點</h3><p>直接能夠獲取到所有父親節點， 這個對應的值是 <code>body</code> 下的所有節點信息。<br>如同 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent\">MDN 文件</a>提到：<br>「回傳一個指向最近的 (指包含層級上的最近) 包含該元素的定位元素或者最近的 <code>table</code>,<code>td</code>,<code>th</code>,<code>body</code> 元素。當元素的 <code>style.display</code> 設置為 <code>none</code> 時，<code>offsetParent</code> 回傳 <code>null</code>。<br><code>offsetParent</code> 很有用，因為 <code>offsetTop</code> 和<code>offsetLeft</code> 都是相對於其內邊距邊界的」。</p>\n<h2 id=\"獲取兄弟節點的方式\"><a href=\"#獲取兄弟節點的方式\" class=\"headerlink\" title=\"獲取兄弟節點的方式\"></a>獲取兄弟節點的方式</h2><h3 id=\"Node-previousSibling\"><a href=\"#Node-previousSibling\" class=\"headerlink\" title=\"Node.previousSibling\"></a>Node.previousSibling</h3><p>透過 <code>Node.previousSibling</code> 可以取得同層之間的「前一個」節點，如果 <code>node</code> 已經是第一個節點，則回傳 <code>null</code>。<br>類似方法還有 <code>previousElementSibling</code> 他們的區別是 <code>Node.previousSibling</code> 會匹配字符，包括換行和空格，而不是節點。<code>previousElementSibling</code> 則直接匹配節點。</p>\n<h3 id=\"Node-nextSibling\"><a href=\"#Node-nextSibling\" class=\"headerlink\" title=\"Node.nextSibling\"></a>Node.nextSibling</h3><p>與 <code>Node.previousSibling</code> 類似，透過 <code>Node.nextSibling</code> 可以取得同層之間的「下一個」節點，如果 <code>node</code> 已經是最後一個節點，則回傳 <code>null</code>。<br>同 <code>Node.previousSibling</code> 和 <code>previousElementSibling</code>，<code>Node.nextSibling</code> 和<code>nextElementSibling</code> 也是類似的。<br>如同 <a href=\"https://www.w3schools.com/jsref/prop_node_nextsibling.asp\">w3schools</a> 提到：</p>\n<blockquote>\n<p>The difference between this property and nextElementSibling, is that nextSibling returns the next sibling node as an element node, a text node or a comment node, while nextElementSibling returns the next sibling node as an element node (ignores text and comment nodes).</p>\n</blockquote>\n<p><code>Node.nextSibling</code> 會回傳下一個兄弟節點作為元素節點，文本節點或註釋節點<br>而 <code>nextElementSibling</code> 回傳下一個兄弟節點作為元素節點（忽略文本和註釋節點）。</p>\n<p>以上內容除了參考 「MDN 文件」外也參考以下文章<br><a href=\"https://blog.csdn.net/laok_/article/details/75760572\">JS 獲取子節點、父節點和兄弟節點的若干種方式</a><br><a href=\"https://ithelp.ithome.com.tw/articles/10191765\">重新認識 JavaScript: Day 12 透過 DOM API 查找節點</a></p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"VueCli 編譯後的網站上傳到 GitHub gh-pages 分支","url":"/blog/2020/11/07/github-gh-page/","content":"<p>這邊整理 <code>VueCli</code> 編譯後的檔案上傳到 <code>GitHub</code> 流程</p>\n<a id=\"more\"></a>\n<h2 id=\"編譯前的設定\"><a href=\"#編譯前的設定\" class=\"headerlink\" title=\"編譯前的設定\"></a>編譯前的設定</h2><p>以 <code>VueCli 2</code> 來說需設定 <code>config/index.js</code> 裡面的 <code>build</code> 中的 <code>assetsPublicPath</code><br>改其值為 <code>/repository 名稱/</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-7.png\"></p>\n<p>若為 <code>VueCli 3</code> ( 含 ) 以上的版本則在專案根目錄新增 <code>vue.config.js</code> 做設定<br>在 <a href=\"https://cli.vuejs.org/zh/config/#publicpath\">Vue 官方文件</a>有說明</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  publicPath: process.env.NODE_ENV === <span class=\"string\">&#x27;production&#x27;</span></span><br><span class=\"line\">    ? <span class=\"string\">&#x27;/repository 名稱/&#x27;</span></span><br><span class=\"line\">    : <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如下圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-10.png\"></p>\n<p>設定好後才執行 <code>npm run build</code> 編譯網站<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-8.png\"></p>\n<p>執行後會出現 <code>dist</code> 資料夾<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-9.png\"></p>\n<h2 id=\"進入-dist-資料夾和建立分支\"><a href=\"#進入-dist-資料夾和建立分支\" class=\"headerlink\" title=\"進入 dist 資料夾和建立分支\"></a>進入 dist 資料夾和建立分支</h2><p>執行 <code>cd dist</code> 進入到 <code>dist</code> 資料夾，與之前一樣建立數據庫和 <code>commit</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-11.png\"></p>\n<p>接著設置遠端分支使用下面的指令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push <span class=\"string\">&#x27;遠端 repository&#x27;</span> master:gh-pages</span><br></pre></td></tr></table></figure>\n<p>如下圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-12.png\"></p>\n<p>上傳到 <code>GitHub</code> 後再重新整理網頁，就看到已經有 <code>gh-pages</code> 分支<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-13.png\"></p>\n<p>點選進去後可看到 <code>dist</code> 資料夾內的檔案，點右上角的 <code>Settings</code>，可進入設定畫面<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-14.png\"></p>\n<p>網頁移到下方可看到 <code>GitHub pages</code> 內容已經幫我們設定網頁畫面預覽的 <code>Source</code> 為 <code>gh-pages</code> 分支<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-15.png\"></p>\n<p>打開連結可看到網頁內容<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-16.png\"></p>\n","categories":["GitHub"],"tags":["Vue","GitHub"]},{"title":"for 迴圈","url":"/blog/2020/10/12/for-loop/","content":"<p><code>for 迴圈</code>常見問題及用法</p>\n<a id=\"more\"></a>\n<h2 id=\"為何下方全域結果是-3\"><a href=\"#為何下方全域結果是-3\" class=\"headerlink\" title=\"為何下方全域結果是 3\"></a>為何下方全域結果是 3</h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(var i=0; i&lt;3; i++) &#123;</span><br><span class=\"line\">  console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(<span class=\"string\">&quot;外層&quot;</span>,i) //3</span><br></pre></td></tr></table></figure>\n<p>流程如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">3&gt;0 成立，跑完 &#123;&#125; 內容後，i++ 後，i 變成1</span><br><span class=\"line\">3&gt;1 成立，跑完 &#123;&#125; 內容後，i 變成2</span><br><span class=\"line\">3&gt;2 成立，跑完 &#123;&#125; 內容後，i++，i 變成 3</span><br><span class=\"line\">3&gt;3 不成立，到這 i 還是等於 3</span><br></pre></td></tr></table></figure>\n<p>所以 當 <code>i=2</code> 成立跑完後， 進行 <code>i++</code>，會變成 3，這樣 3 才能在下個迴圈判斷是否有成立條件哩</p>\n<p>因為當 <code>i</code> 跑到 3 時候，3 不小於 3 所以跳出迴圈<br>但在迴圈中用 <code>var</code> 宣告 <code>i</code> 會把 <code>i</code> 添加到 <code>window</code> 底下變成全域變數，<br>所以 <code>i</code> 最後的值是 3 </p>\n<h2 id=\"for-迴圈-length-的宣告與不宣告變數\"><a href=\"#for-迴圈-length-的宣告與不宣告變數\" class=\"headerlink\" title=\"for 迴圈 length 的宣告與不宣告變數\"></a>for 迴圈 length 的宣告與不宣告變數</h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = [5, 8, 15];</span><br><span class=\"line\">var len = data.length;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=0; i&lt;len; i++) &#123;</span><br><span class=\"line\">  console.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>宣告變數給 <code>length</code>，需注意如果迴圈並非取的是陣列內容，而是自定義數字<br>在迴圈執行階段記憶體還沒釋放，所以還是舊內容<br>所以在此是建議直接用 <code>length</code> 隨時抓取長度，缺點是效能就會明顯不好</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = [5, 8, 15];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=0; i&lt;data.length; i++) &#123;</span><br><span class=\"line\">  console.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>若直接使用 <code>data.length</code> 每跑一次 <code>for 迴圈</code>他就還必須偵測陣列長度一次<br>因為重複計算長度而導致資料量大時，效能就會明顯不好<br>而使用變數儲存 <code>data.length</code> 因直接取得數量，所以相較之下效能會比較好</p>\n<h2 id=\"for-迴圈的-length-全域和區域宣告\"><a href=\"#for-迴圈的-length-全域和區域宣告\" class=\"headerlink\" title=\"for 迴圈的 length 全域和區域宣告\"></a>for 迴圈的 length 全域和區域宣告</h2><p>如果在 <code>for</code> 迴圈內宣告區域變數的話，他每次只要跑一次 <code>for 迴圈</code>裡面的區域變數都會被歸零，也就導致不會累加，所以抓到的內容就只會是最後一筆資料，也就是 140<br>因此要在外層全域宣告變數才能夠累加結果</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var farms = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;艾文&quot;</span>,</span><br><span class=\"line\">    feild: 6,</span><br><span class=\"line\">    chick: 120</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;史考特&quot;</span>,</span><br><span class=\"line\">    feild: 10,</span><br><span class=\"line\">    chick: 30</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;約翰&quot;</span>,</span><br><span class=\"line\">    feild: 6,</span><br><span class=\"line\">    chick: 140</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">// 區域變數</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=0; i&lt;farms.length;i++) &#123;</span><br><span class=\"line\">  var totalchick = 0;</span><br><span class=\"line\">  totalchick += farms[i].chick;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(totalchick); //140</span><br><span class=\"line\"></span><br><span class=\"line\">// 全域變數</span><br><span class=\"line\">var totalchick = 0;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i=0; i&lt;farms.length;i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  totalchick += farms[i].chick;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(totalchick); //290</span><br></pre></td></tr></table></figure>\n\n<p><strong>關於 <code>+=</code></strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">totalchick += farms[i].chick;</span><br></pre></td></tr></table></figure>\n<p>若有內容要加上去，又不影響原本的字串，那就可以用</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">totalchick = totalchick + <span class=\"string\">&#x27;abc&#x27;</span> </span><br></pre></td></tr></table></figure>\n<p>而 <code>totalchick+=&#39;abc&#39;</code>，就是一種縮寫方式，此種方式等同於</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">totalchick = totalchick+ <span class=\"string\">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for-迴圈-i-寫法\"><a href=\"#for-迴圈-i-寫法\" class=\"headerlink\" title=\"for 迴圈 - i++ 寫法\"></a>for 迴圈 - i++ 寫法</h2><p>下面都是同樣內容，不同的表達方式</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">i = i + 1;</span><br><span class=\"line\">i += 1;</span><br><span class=\"line\">i++;</span><br></pre></td></tr></table></figure>\n<p><code>i++</code>，他先回傳數值，所以回傳 1，接著再度呼叫時候再加上 1<br>另外也有一種 <code>++i</code><br><code>++i</code>，他本身加 1，所以回傳 2 ，接著再度呼叫時候再回傳加總後的數值<br>兩種差別可參考這個<a href=\"https://codepen.io/HexSchool_yuko/pen/ymeNeV\">範例</a></p>\n<h2 id=\"for-迴圈與-break-運用\"><a href=\"#for-迴圈與-break-運用\" class=\"headerlink\" title=\"for 迴圈與 break 運用\"></a>for 迴圈與 break 運用</h2><p><code>break</code> 和 <code>if</code> 以及 <code>for 迴圈</code>，這是要看使用狀況而定，在此做個<a href=\"https://codepen.io/HexSchool_yuko/pen/OejrLM\">小範例</a></p>\n<p>如果單使用 <code>if</code>，在此範例只能判斷是否有撈到陣列資料如 JS 第 23 行所顯示一樣<br>會使用迴圈是因為要從陣列去撈資料出來顯示<br> JS 第 28 行，如果只是想撈一筆農夫資料就在迴圈中直接加上 <code>break</code>，讓他只跑一次迴圈<br> JS 第 37 行，想知道哪些農場的小雞有 100 隻以上，就在迴圈中加入 <code>if 判斷</code>讓他跑出相應的資料<br> JS 第 48 行，只列出 1 筆有符合有養 100 隻小雞以上的農場<br>這些都是依照使用情境狀況而去設計的程式<br>下面這篇文章在敘述使用 <code>break</code> 的狀況，裡面有說為何需要 <code>break</code><br><a href=\"https://blog.csdn.net/XXJ19950917/article/details/78310346\">https://blog.csdn.net/XXJ19950917/article/details/78310346</a><br>「如果一個循環的終止條件非常複雜，那麼使用 <code>break</code> 語句來實現某些條件比用一個循環表達式所有的條件容易得多。」</p>\n<h2 id=\"splice-刪除和更新-for-迴圈資料的情況\"><a href=\"#splice-刪除和更新-for-迴圈資料的情況\" class=\"headerlink\" title=\"splice 刪除和更新 for 迴圈資料的情況\"></a>splice 刪除和更新 for 迴圈資料的情況</h2><p>這個 <a href=\"https://codepen.io/HexSchool_yuko/pen/JjKeBvw\">Codepen 裡面的範例</a>有出現無法刪除的錯誤狀況</p>\n<p>因為 <code>len</code> 和 <code>str</code> 需要放在 <code>updateList ()</code> 內</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var len=listarea.length;</span><br><span class=\"line\">var str=<span class=\"string\">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>也就是刪除資料時， <code>listarea</code> 的資料會變更</p>\n<p>但 <code>var len=listarea.length;</code> 放在全域環境下<br>所取得的資料長度是一開始的 3 筆資料<br>因此導致刪除出錯</p>\n<p>而 <code>var str=&#39;&#39;;</code> 放在全域則會累加全域的 <code>listarea</code> 資料<br>所以建議這兩行都要放在 <code>updateList ()</code> 內</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"innerhtml","url":"/blog/2020/09/12/innerhtml/","content":"<p><code>innerHTML</code> 在處理迴圈或是字串會遇到常見的問題，如下文所示：</p>\n<a id=\"more\"></a>\n<h2 id=\"innerHTML-組字串的引號問題\"><a href=\"#innerHTML-組字串的引號問題\" class=\"headerlink\" title=\"innerHTML 組字串的引號問題\"></a>innerHTML 組字串的引號問題</h2><p>如果外層是單引號，裡層包起來就要是雙引號，因為如果同樣是單引號，他不知道結束點在哪，會以為是在圈選處結束，如下圖，而出現紅色底線<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20200912_innerhtml/innerhtml-1.png\"></p>\n<p>更改如下<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20200912_innerhtml/innerhtml-2.png\"></p>\n<p>innerHTML 可以累加<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20200912_innerhtml/innerhtml-3.png\"></p>\n<p>結果如下，會出現兩次<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20200912_innerhtml/innerhtml-4.png\"></p>\n<h2 id=\"innerHTML-與-for-運用\"><a href=\"#innerHTML-與-for-運用\" class=\"headerlink\" title=\"innerHTML 與 for 運用\"></a>innerHTML 與 for 運用</h2><p><code>list.innerHTML</code> 的位置是否可以放在 <code>for 迴圈</code>裡面呢？</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> updateList(e)&#123;</span><br><span class=\"line\">    var selected=e.target.value;</span><br><span class=\"line\">    var str=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(var i=0;i&lt;country.length;i++)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(selected===country[i].place)&#123;</span><br><span class=\"line\">             str+=<span class=\"string\">&quot;&lt;li&gt;農夫名字是：&quot;</span>+country[i].farmer+<span class=\"string\">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class=\"line\">             list.innerHTML=str;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>邏輯上雖是可行，但是程式執行時，會屢次向網頁進行渲染，也就是不斷的重複寫入<br>所以比較好的方式是在放在 <code>for 迴圈</code>後面 (如下) ，當字串累加後，後面再執行 <code>innerHTML</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> updateList(e)&#123;</span><br><span class=\"line\">    var selected=e.target.value;</span><br><span class=\"line\">    var str=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(var i=0;i&lt;country.length;i++)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(selected===country[i].place)&#123;</span><br><span class=\"line\">             str+=<span class=\"string\">&quot;&lt;li&gt;農夫名字是：&quot;</span>+country[i].farmer+<span class=\"string\">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class=\"line\">         &#125;;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">    list.innerHTML=str;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"說明用法\"><a href=\"#說明用法\" class=\"headerlink\" title=\"+= 說明用法\"></a>+= 說明用法</h2><p>當在寫 <code>var str=&#39;hi&#39;</code> 時，裡面就被賦予字串，<br>而若有內容需要加上去，又不能影響原本的字串，<br>那就可以用</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">str( 原變數 ) = ( 重新賦予值 )  str( 原變數內容 )+ <span class=\"string\">&#x27;Sue&#x27;</span> 字串</span><br><span class=\"line\">str = str +  <span class=\"string\">&#x27;Sue&#x27;</span> </span><br></pre></td></tr></table></figure>\n<p>而 <code>str+=&#39;Sue&#39;</code>，就是一種縮寫方式，此種等同於 <code>str = str+ &#39;Sue&#39;</code><br>如果不習慣這樣的縮寫，可直接用 <code>str = str + &#39;Sue&#39;</code> 這種寫法</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"hexo 上傳圖片解決方式","url":"/blog/2020/09/12/hexo-%E4%B8%8A%E5%82%B3%E5%9C%96%E7%89%87%E8%A7%A3%E6%B1%BA%E6%96%B9%E5%BC%8F/","content":"<p>這邊紀錄 `hexo 需要附上圖片的處理方式</p>\n<a id=\"more\"></a>\n<h2 id=\"本地上傳圖片\"><a href=\"#本地上傳圖片\" class=\"headerlink\" title=\"本地上傳圖片\"></a>本地上傳圖片</h2><p>在 <code>hexo</code> 根目錄的 <code>_config.yml</code> 裡面有個</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">post_asset_folder: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>改設定值為 true</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">post_asset_folder: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>可使用 <code>hexo cl</code> 清除之前建立的靜態檔案和 <code>hexo s</code>重啟網站<br>接著執行 <code>hexo new 新文章名稱</code> 建立新文章<br><code>source/_post</code> 裡面就會出現除了新文章外還有新文章名稱的資料夾<br>可將圖片放在該資料夾中<br>並依照<a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">官網文件</a>用標籤方式來設定</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img slug 圖片名稱.png %&#125;</span><br></pre></td></tr></table></figure>\n<p>只改上面程式碼內的 <code>圖片名稱.png</code> 即可<br>最後執行 <code>hexo cl</code> 清除之前建立的靜態檔案和 <code>hexo s</code> 重啟網站就可看到圖片</p>\n<h2 id=\"利用-GitHub-來當圖床，並引用其網址\"><a href=\"#利用-GitHub-來當圖床，並引用其網址\" class=\"headerlink\" title=\"利用 GitHub 來當圖床，並引用其網址\"></a>利用 GitHub 來當圖床，並引用其網址</h2><p>首先可先參考這個 <a href=\"https://youtu.be/0UKyACaKMC4\">youtube 影片</a> 新增 <code>GitHub</code> 和上傳圖片到 <code>GitHub</code></p>\n<p>接著在文章內使用 <code>Markdown</code> 語法</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">![](https://帳號名稱.github.io/repo 名稱/xxx.png)</span><br></pre></td></tr></table></figure>","categories":["hexo"],"tags":["hexo"]},{"title":"VueCli 上傳到 GitHub 相關流程","url":"/blog/2020/11/07/github-vuecli/","content":"<p>這邊整理 <code>VueCli</code> 原始檔案上傳到 <code>GitHub</code> 流程</p>\n<a id=\"more\"></a>\n<h2 id=\"GitHub-新增-Repository\"><a href=\"#GitHub-新增-Repository\" class=\"headerlink\" title=\"GitHub 新增 Repository\"></a>GitHub 新增 Repository</h2><p>要把網站上傳到 <code>GitHub</code> 除了要在電腦安裝 <code>Git</code> 和註冊 <code>GitHub</code> 外<br>( 安裝 <code>Git</code> 可參考<a href=\"https://youtu.be/VufCg58gysE\">「六角學院線上問答會 Git 安裝流程」</a>)<br>也需要新增數據庫 (<code>repository</code>)，如下圖設定<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-1.png\"><br>這邊只要設定數據庫名稱 (<code>Repository name</code>)，也就是上圖 Repository name<br>綠色打勾代表可以用這個名稱來建立 <code>repository</code>，接著按下綠色按鈕進行下一步<br>接著會跑出 <code>Quick setup</code> 畫面，這邊就需要紀錄 <code>.git</code> 的連結，方便我們把資料上傳<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-2.png\"></p>\n<h2 id=\"本地端設定要傳送到-GitHub-的資料\"><a href=\"#本地端設定要傳送到-GitHub-的資料\" class=\"headerlink\" title=\"本地端設定要傳送到 GitHub 的資料\"></a>本地端設定要傳送到 GitHub 的資料</h2><p>這邊要把 <code>VueCli 2</code> 上傳到 <code>GitHub</code> 需要先在建立本地數據庫<br>也就是 <code>git init</code><br>接著把全部檔案新增索引，就使用 <code>git add .</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-3.png\"><br>因為 <code>Git</code> 是版本控制，所以需要有文字說明這次更新內容，因此需要執行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit -m <span class=\"string\">&#x27;編輯記錄&#x27;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-4.png\"><br>然後上傳到遠端數據庫，先添加一個遠端數據庫 <code>git remote add</code><br>之後才用 <code>git push</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote add &lt;name&gt; &lt;url&gt;</span><br><span class=\"line\">git push &lt;name&gt; master</span><br><span class=\"line\">// name 為數據庫名稱</span><br><span class=\"line\">// url 為 .git 連結位址</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-5.png\"></p>\n<p>上傳到 <code>GitHub</code> 後再重新整理網頁，就看到資料已經都上傳<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201107_github/vuecli-6.png\"></p>\n","categories":["GitHub"],"tags":["Vue","GitHub"]},{"title":"input.value 取值狀況","url":"/blog/2020/09/11/input_value/","content":"<p><code>input value</code> 會有取值的狀況，如下文所示：</p>\n<a id=\"more\"></a>\n<h2 id=\"全域與區域設定-input-value-差異\"><a href=\"#全域與區域設定-input-value-差異\" class=\"headerlink\" title=\"全域與區域設定 input value 差異\"></a>全域與區域設定 input value 差異</h2><p>全域設定 <code>input.value</code> 時，如果 <code>HTML</code> 沒有設 <code>value</code> 網頁載入時候會是空值<br>可參考這個<a href=\"https://codepen.io/HexSchool_yuko/pen/QXXPvm\">範例</a></p>\n<h2 id=\"清空-input-value\"><a href=\"#清空-input-value\" class=\"headerlink\" title=\"清空 input.value\"></a>清空 input.value</h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">addTodo</span></span>() &#123;</span><br><span class=\"line\">var txt = document.querySelector(<span class=\"string\">&#x27;.text&#x27;</span>).value;</span><br><span class=\"line\">txt = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因為 <code>txt</code> 是儲存 <code>input</code> 元素的值<br>換句話說是新增記憶體 ( 變數 <code>txt</code>) 來存放 <code>document.querySelector(&#39;.text&#39;).value</code><br>並非取得當下的 <code>input</code> 元素的值<br>所以會建議直接使用 <code>txt.value</code><br>因此改為 <code>var txt = document.querySelector(&#39;.text&#39;);</code><br>並用 <code>txt.value</code> 就能清空當下的 <code>input.value</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">addTodo</span></span>() &#123;</span><br><span class=\"line\">var txt = document.querySelector(<span class=\"string\">&#x27;.text&#x27;</span>);</span><br><span class=\"line\">txt.value = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"限制-input-輸入長度\"><a href=\"#限制-input-輸入長度\" class=\"headerlink\" title=\"限制 input 輸入長度\"></a>限制 input 輸入長度</h2><p>限制字數可使用 <code>maxlength</code> 若 <code>type=&quot;number&quot;</code> 是無法使用這個語法，需改為 <code>type=&quot;tel&quot;</code><br>可參考這篇<a href=\"https://www.itread01.com/articles/1498672640.html\">文章</a></p>\n<h2 id=\"input-欄位如不輸入內容會是-“”-，如轉為數字則會是-NaN\"><a href=\"#input-欄位如不輸入內容會是-“”-，如轉為數字則會是-NaN\" class=\"headerlink\" title=\"input 欄位如不輸入內容會是 “” ，如轉為數字則會是 NaN\"></a>input 欄位如不輸入內容會是 “” ，如轉為數字則會是 NaN</h2><p>可參考 <a href=\"https://stackoverflow.com/a/44264395\">stackoverflow 討論</a><br>裡面提到沒輸入 <code>value</code> 就會是 <code>&quot;&quot;</code><br>但該欄位如果有轉型為 <code>Number</code><br>則會得到 <code>NaN</code></p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"mouse 滑過事件差異","url":"/blog/2020/10/15/mouseevent/","content":"<p>整理一些 <code>mouse</code> 滑過事件差異</p>\n<a id=\"more\"></a>\n<h2 id=\"事件解釋\"><a href=\"#事件解釋\" class=\"headerlink\" title=\"事件解釋\"></a>事件解釋</h2><ul>\n<li><p><code>mouseover</code> : 當滑鼠移動到被選元素和被選元素的子元素時，<code>mouseover</code> 事件就會被觸發。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseover_event\">mouseover MDN 文件</a></p>\n</li>\n<li><p><code>mousemove</code> : 當滑鼠移動到被選元素內後，<code>mousemove</code> 事件被觸發。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mousemove_event\">mousemove MDN 文件</a></p>\n</li>\n<li><p><code>mouseenter</code>: 當滑鼠移動到元素上時就會觸發 <code>mouseenter</code> 事件，類似 <code>mouseover</code>，它們兩者之間的差別是 <code>mouseenter</code> 不會冒泡（bubble），也就是說當游標從它的子層物理空間移到它的物理空間上時不會觸發<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mouseenter_event\">mouseenter MDN 文件</a></p>\n</li>\n</ul>\n<h2 id=\"相關討論文章\"><a href=\"#相關討論文章\" class=\"headerlink\" title=\"相關討論文章\"></a>相關討論文章</h2><ul>\n<li><code>jQuery</code> 的 <code>mouseover()</code> 與  <code>hover()</code> 差異可參考 <a href=\"https://stackoverflow.com/questions/17589420/when-to-choose-mouseover-and-hover-function\">stackoverflow 討論</a><ul>\n<li><code>mouseover()</code>：將事件綁定在「<code>mouseover</code>」 <code>JavaScript</code>事件，或在元素上觸發該事件。</li>\n<li><code>hover()</code>：將一個或兩個處理程序綁定到匹配的元素，以在滑鼠游標進入和離開元素時執行。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><code>CSS hover</code> 與 <code>JavaScript mouseover</code> 討論可參考 <a href=\"https://stackoverflow.com/questions/608788/css-hover-vs-javascript-mouseover\">stackoverflow 討論</a><ul>\n<li>討論中有人提到 CSS 比較好維護，也有提到 <code>CSS hover</code> 在 <code>IE6</code> 雖可支援，但因為後來的 <code>IE7</code> 對 <code>CSS2</code> 的支持程度約為<code>50%</code> 所以不支援 <code>div：hover</code></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><code>javascript</code> 中 <code>mouseenter</code> 與 <code>mouseover</code> 差異也可看下面的文章</p>\n<ul>\n<li><p><a href=\"https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/236517/\">javascript 中 mouseenter 與 mouseover 的異同</a><br>裡面也提供<a href=\"https://qianlongo.github.io/zepto-analysis/example/event/mouseEnter-mouseOver.html\">範例</a>來顯示其差異</p>\n</li>\n<li><p><a href=\"https://www.geeksforgeeks.org/difference-between-mouseover-mouseenter-and-mousemove-events-in-javascript/\">Difference between mouseover, mouseenter and mousemove events in JavaScript</a><br>裡面提供 <code>mouseover</code>、<code>mouseenter</code>、<code>mousemove</code> 簡單說明</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["JavaScript"],"tags":["JavaScript","HTML","jQuery"]},{"title":"onclick 和 addEventListener 綁定事件","url":"/blog/2020/10/21/onclick&addEventListener/","content":"<p>綁定事件 <code>onclick</code> 和 <code>addEventListener</code> 的常見問題</p>\n<a id=\"more\"></a>\n<h2 id=\"括號問題\"><a href=\"#括號問題\" class=\"headerlink\" title=\"括號問題\"></a>括號問題</h2><h3 id=\"onclick\"><a href=\"#onclick\" class=\"headerlink\" title=\"onclick\"></a>onclick</h3><p><code>onclick</code> 在 <code>HTML 標籤</code>使用 <code>onclick</code> 指令時，請加上括號<br>在 <code>JS</code> 上要使用 <code>onclick</code> 時，不需要加上括號，因為會自動執行該 <code>function</code>，可以想像他會在該函式自動幫你加上 <code>()</code></p>\n<h3 id=\"addEventListenter-中間函數不能用-帶參數狀況\"><a href=\"#addEventListenter-中間函數不能用-帶參數狀況\" class=\"headerlink\" title=\"addEventListenter 中間函數不能用 () 帶參數狀況\"></a>addEventListenter 中間函數不能用 () 帶參數狀況</h3><p>在這個<a href=\"https://codepen.io/HexSchool_yuko/pen/yLNPoKM\">範例</a><br><code>addEventListener</code> 第 2 行的 <code>addArea</code><br>在沒有點按鈕的狀況下，就會立刻執行 <code>addArea</code> 內容<br>如果要讓 <code>addArea()</code> 在按鈕觸發時候帶參數<br>可參考 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/EventTarget/addEventListener\">MDN 文件中的「匿名函數的事件監聽」</a><br>因此 <code>addArea</code> 可改寫如下，也就是範例第 9 行內容<br>以上可參考<a href=\"https://stackoverflow.com/a/16588082\">stackoverflow 討論</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">btn.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">  addArea(<span class=\"string\">&quot;苓雅區&quot;</span>)</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"綁定事件語法差異\"><a href=\"#綁定事件語法差異\" class=\"headerlink\" title=\"綁定事件語法差異\"></a>綁定事件語法差異</h2><p><code>onclick</code> 只能綁定單一事件，如同這個<a href=\"https://codepen.io/HexSchool_yuko/pen/gOMwjzV\">範例</a> JS 欄位 1-7 行，雖然按鈕綁定兩個事件，但按鈕只會觸發最後一個事件</p>\n<p><code>addEventListener</code>則可綁定多個事件，在範例 JS 欄位 9-15 行裡面，兩個事件都有被綁定</p>\n<h2 id=\"addEventListener-冒泡和捕捉事件\"><a href=\"#addEventListener-冒泡和捕捉事件\" class=\"headerlink\" title=\"addEventListener 冒泡和捕捉事件\"></a>addEventListener 冒泡和捕捉事件</h2><p>針對 <code>addEventListenter</code> 後方的 <code>false</code> 做說明，可參考這個<a href=\"https://codepen.io/HexSchool_yuko/pen/ZEWpmzw\">範例</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span> (事件氣泡 - event Bubbling) - 從指定元素往外找</span><br><span class=\"line\"><span class=\"literal\">true</span> (事件捕捉 - event capturing) - 從最外面找到指定元素</span><br></pre></td></tr></table></figure>\n\n<p>所以選擇 <code>false</code> 會比較合乎邏輯，點擊最近元素觸發事件<br>可是有時會希望由外往內，所以會需要 <code>true</code><br>不寫的話預設為 <code>false</code></p>\n<p>也可參考這篇 <a href=\"https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/\">DOM 的事件傳遞機制：捕獲與冒泡</a><br>文中敘述也有提到 <code>addEventListener</code> 的第三個參數解釋<br>「其實，一樣是用大家所熟悉的 <code>addEventListener</code>，只是這函數其實有第三個參數，<br><code>true</code> 代表把這個 <code>listener</code> 添加到捕獲階段，<code>false</code> 或是沒有傳就代表把這個 <code>listener</code> 添加到冒泡階段。」</p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"「null」與「空字串」的差別","url":"/blog/2020/09/21/null-string-empty/","content":"<p>關於「<code>null</code>」與「空字串」的差別，簡單分辨如下：</p>\n<a id=\"more\"></a>\n<p>null 和 空字串(<code>&#39;&#39;</code>) 的意思，可參考<a href=\"https://dotblogs.com.tw/gra/2018/06/10/121512\">這篇文章</a><br>文章內用裝水的容器來做比喻<br>空字串：本來裝水的容器今天沒裝水。<br><code>null</code> ：一個是連裝水的容器都沒有。<br><code>null</code> 常用在判斷這個變數是否為 <code>null</code>，接著去做執行下一步動作<br>而有些開發者不希望變數設置成 <code>let a = &#39;&#39;</code> 或是 <code>let a = &#123;&#125;</code><br>就會使用 <code>let a = null</code></p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"querySelector","url":"/blog/2020/10/20/querySelector/","content":"<p><code>querySelector</code> 和 <code>querySelectorAll</code> 選取元素用法介紹</p>\n<a id=\"more\"></a>\n<h2 id=\"querySelector-選取單一元素\"><a href=\"#querySelector-選取單一元素\" class=\"headerlink\" title=\"querySelector 選取單一元素\"></a>querySelector 選取單一元素</h2><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var el = document.querySelector(<span class=\"string\">&#x27;.box&#x27;</span>);</span><br><span class=\"line\">var el_id = document.querySelector(<span class=\"string\">&#x27;#boxid&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>括號內接 <code>class</code> 或是 <code>id</code><br><code>class</code> 為 <code>.</code><br><code>id</code> 為 <code>#</code><br>與 <code>CSS</code> 寫法一樣</p>\n<h2 id=\"querySelectorAll-可重複選取多個元素\"><a href=\"#querySelectorAll-可重複選取多個元素\" class=\"headerlink\" title=\"querySelectorAll - 可重複選取多個元素\"></a>querySelectorAll - 可重複選取多個元素</h2><p>下方的 <code>.box</code> 若用 <code>querySelector</code> 則只會選到第一個 <code>.box</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=<span class=\"string\">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var el = document.querySelector(<span class=\"string\">&#x27;.box&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>所以需改用 <code>querySelectorAll</code> 才能選到所有的 <code>.box</code> </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=<span class=\"string\">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=<span class=\"string\">&quot;box&quot;</span>&gt;&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var el = document.querySelectorAll(<span class=\"string\">&#x27;.box&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>若要讓 <code>.box</code> 加上內容可跑 <code>for 迴圈</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var el = document.querySelectorAll(<span class=\"string\">&#x27;.box&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(var i = 0; i &lt; el.length; i++) &#123;</span><br><span class=\"line\">  el[i].textContent = <span class=\"string\">&#x27;項目&#x27;</span>+ i;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>這邊有個地方要注意 <code>querySelectAll</code> 取出的值為 <code>NodeList</code> 也是類陣列<br>也就是代表選取到所有符合條件的元素，是一個集點的集合 <code>NodeList</code><br>可參考 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/API/NodeList\">MDN 文件</a><br>因此他無法使用陣列型別的 <code>method</code> ，但仍可使用索引存取內容<br>類陣列轉為陣列常見方式可透過「展開」、「<code>Array.from</code>」<br>另外 <code>el.length</code> 可以看成是被選取到的元素數量<br>所以 <code>for 迴圈</code> 也是可以使用的</p>\n<h2 id=\"querySelector-amp-getElementByXX-的差別\"><a href=\"#querySelector-amp-getElementByXX-的差別\" class=\"headerlink\" title=\"querySelector &amp; getElementByXX 的差別\"></a>querySelector &amp; getElementByXX 的差別</h2><p><code>querySelector</code> 是屬於靜態結果， 而 <code>getElementByXX</code> 是屬於動態結果<br>如同這篇<a href=\"https://ithelp.ithome.com.tw/articles/10230686?sc=rss.qu\">鐵人賽文章範例</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul id=<span class=\"string\">&quot;myul&quot;</span>&gt;</span><br><span class=\"line\">    &lt;li&gt;li 1&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;li 2&lt;/li&gt;</span><br><span class=\"line\">    &lt;li&gt;li 3&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用 getElementBy 系列取得 li 清單</span><br><span class=\"line\">var ulbyid = document.getElementById(<span class=\"string\">&#x27;myul&#x27;</span>);</span><br><span class=\"line\">var libytag = ulbyid.getElementsByTagName(<span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用 querySelector 取得 li 清單</span><br><span class=\"line\">var ulqs = document.querySelector(<span class=\"string\">&#x27;ul&#x27;</span>);</span><br><span class=\"line\">var ulqsa = ulqs.querySelectorAll(<span class=\"string\">&#x27;li&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">// 輸出取得的清單長度都是 3</span><br><span class=\"line\">console.log(libytag.length); // 3</span><br><span class=\"line\">console.log(ulqsa.length); // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 在 ulbyid 加入新的 li 元素</span><br><span class=\"line\">ulbyid.appendChild(document.createElement(<span class=\"string\">&#x27;li&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">// 再次輸出清單長度</span><br><span class=\"line\">console.log(libytag.length); // 4</span><br><span class=\"line\">console.log(ulqsa.length); // 3</span><br><span class=\"line\"></span><br><span class=\"line\">// 在 ulqsa 加入新的 li 元素</span><br><span class=\"line\">ulbyid.appendChild(document.createElement(<span class=\"string\">&#x27;li&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">// 再次輸出清單長度</span><br><span class=\"line\">console.log(libytag.length); // 5</span><br><span class=\"line\">console.log(ulqsa.length); // 3</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>文章中提到<br>「<code>getElementBy...</code> 系列都能抓到當前所有項目(有點像自動更新的功能), 而 <code>querySelector</code> 在取得後不管加了多少新元素, 都只有取得當下的清單內容而已」</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"AJAX 區域問題","url":"/blog/2020/10/24/AJAX-%E5%8D%80%E5%9F%9F%E5%95%8F%E9%A1%8C/","content":"<p>若要按鈕觸發 <code>AJAX</code> 事件需注意區域問題</p>\n<a id=\"more\"></a>\n<p>透過 <code>XMLHttpRequest</code> 物件跨瀏覽器撈資料時候會有要觸發按鈕事件的狀況<br>例如透過按鈕來登入和註冊等事件<br>可參考這個 <a href=\"https://codepen.io/HexSchool_yuko/pen/OJXWwrG\">codepen 範例</a><br>裡面的 11-16 和 46-51 行放在全域後，第二次按下註冊按鈕或第二次按下登入按鈕會出現下面的錯誤訊息<br>「Uncaught InvalidStateError: Failed to execute ‘send’ on ‘XMLHttpRequest’: The object’s state must be OPENED. 」</p>\n<p><code>xhr.open</code> 和 <code>xhr.setRequestHeader</code> 需在按鈕監聽事件內<br>如果放在全域其實就已經執行 <code>AJAX</code> 行為，因此第一次可以從遠端接到回應<br>但第二次按下並沒有開啟 <code>AJAX</code> 行為，因為第一次全域觸發後就結束，所以就會跳出錯誤訊息<br>所以每一次的 <code>AJAX</code> 行為都要重新建立，也就是要把 <code>xhr.open</code> 和 <code>xhr.setRequestHeader</code>放在按鈕監聽事件內</p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"switch (true) 代替 if / else","url":"/blog/2020/10/14/switch-loop/","content":"<p><code>switch</code> 常見問題</p>\n<a id=\"more\"></a>\n<h2 id=\"switch-case\"><a href=\"#switch-case\" class=\"headerlink\" title=\"switch case\"></a>switch case</h2><p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201014_switch/switch-1.png\"><br>上面結果為何不是哪一個例子進入哪一個的舉例式判斷嗎 ? 為何全部列印出來 ?<br><code>switch</code> 是從哪邊開始執行<br>也就是從上面案例中 <code>weekDay = 3</code> ，是從 <code>3</code> 開始，所以依序往下執行，連同 <code>default</code> 也執行<br>所以 <code>switch</code> 不只是判斷式，他也有進入點的控制<br>依照這邊的內容<code>(weekDay)</code>，去控制程式碼要從哪邊開始</p>\n<p>如果要像是 <code>if else</code> 的判斷式，就要加入 <code>break</code>;<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201014_switch/switch-2.png\"></p>\n<p>缺點是：<br>1.程式碼冗長<br>2.<code>switch()</code> 括號裡的參數 <code>weekDay</code> 的狀態要很清楚，才能<code>handle</code> 全部</p>\n<p>如果 <code>case</code> 的內容一樣可以合併<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201014_switch/switch-3.png\"></p>\n<h2 id=\"switch-true-代替-if-else\"><a href=\"#switch-true-代替-if-else\" class=\"headerlink\" title=\"switch (true) 代替 if / else\"></a>switch (true) 代替 if / else</h2><p>因為 <code>switch</code> 的 <code>case</code> 需要有明確的值<br>所以如果要判斷是否為某個區間範圍的值<br>可將 <code>switch(weight)&#123; &#125;</code> 裡面的 <code>weight</code> 改 <code>true</code> ，修改後如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var weight = 45;</span><br><span class=\"line\">switch(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> (weight &lt; 40):</span><br><span class=\"line\">  console.log(<span class=\"string\">&#x27;有點過瘦唷！&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> (weight &lt;=40 &amp;&amp; weight &lt;=60):</span><br><span class=\"line\">  console.log(<span class=\"string\">&#x27;很適當！&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> (weight &lt;=60 &amp;&amp; weight &lt;= 100):</span><br><span class=\"line\">  console.log(<span class=\"string\">&#x27;過重囉&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"return","url":"/blog/2020/10/20/return/","content":"<p>整理 <code>function</code> 的 <code>return</code> 觀念和用法</p>\n<a id=\"more\"></a>\n<p>關於 <code>function</code> 的 <code>return</code> 比較好理解的方式是<br><code>function</code> 就是一個計算機，當要執行 <code>function</code> 時，就表示要拿起計算機開始算了，<br>此時按下 <code>100 * 10</code>，希望可以結束運算並回傳資料時，就會按計算機的「<code>=</code>」符號來顯示運算結果，<br>進而得到想知道的計算結果。<br>而 <code>return</code> 就是計算機的「<code>=</code>」，按下去就會顯示運算結果了<br>因此 <code>return</code> 之後是不會再執行後面的程式了，直接結束，相當於 <code>break</code><br>所以除了回傳值，還可以當中斷點</p>\n<p>而且其實 <code>function</code> 都要回傳值，若是沒有用 <code>return</code> 回傳，他預設會顯示 <code>undefined</code><br>可參考 <code>stackoverflow</code> 的 <a href=\"https://stackoverflow.com/questions/48362507/console-logmyfunction-returns-undefined\">「console.log(myFunction()) returns undefined」討論內容</a></p>\n<p>關於 <code>return</code> 用法可參考<a href=\"https://blog.csdn.net/yulei_qq/article/details/45317579\">這篇文章</a><br>他下方總結就有說明<br><code>retrun true</code>： 返回正確的處理結果。<br><code>return false</code>：返回錯誤的處理結果、終止處理、阻止提交表單、阻止執行默認的行為。<br><code>return</code>：把控制權返回給頁面。</p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"this 調用方式 (1)","url":"/blog/2020/10/31/this2/","content":"<p><code>this</code> 調用方式：<br>「作為物件方法」和「簡易呼叫」內容</p>\n<a id=\"more\"></a>\n<h2 id=\"作為物件方法-最常運用-this-的方法\"><a href=\"#作為物件方法-最常運用-this-的方法\" class=\"headerlink\" title=\"作為物件方法 (最常運用 this 的方法)\"></a>作為物件方法 (最常運用 <code>this</code> 的方法)</h2><p> <code>this</code> 的指向在物件的方法調用是最常見的形式，以下為兩個重點：</p>\n<blockquote>\n<ul>\n<li><code>this</code> 與函式如何宣告<strong>沒有關聯性</strong>，僅與呼叫方式有關</li>\n<li>物件的方法調用時，僅需要關注<strong>是在哪一個物件</strong>下呼叫</li>\n</ul>\n</blockquote>\n<p>假設在一個物件下去呼叫一個函式，那這個 <code>this</code> 的指向就是前面的物件，只要掌握這個觀念，就可運用最常見的 <code>this</code> 調用方式，如下圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-5.png\"><br>這邊也提供範例參考<br>要注意的是不管是這個函式是如何定義的，只要了解是在哪個物件下來呼叫這個 <code>this</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var item = <span class=\"string\">&#x27;茶壺&#x27;</span>;</span><br><span class=\"line\">var data = &#123;</span><br><span class=\"line\">  item:<span class=\"string\">&#x27;杯子&#x27;</span>,</span><br><span class=\"line\">  num: count,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">count</span></span>() &#123;</span><br><span class=\"line\">  console.log(this.item); // 杯子</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data.num();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-6.png\"></p>\n<h2 id=\"簡易呼叫\"><a href=\"#簡易呼叫\" class=\"headerlink\" title=\"簡易呼叫\"></a>簡易呼叫</h2><p>下方的範例為「簡易呼叫」(<code>simple call</code>)<br><code>simple call</code> 的 <code>this</code> 都指向 <code>window</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num = 10;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">count</span></span>() &#123;</span><br><span class=\"line\">  console.log(this, this.num); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-7.png\"></p>\n<p>這邊要注意一件事情，我們所理解的全域是掛在 <code>window</code> 物件下，所以很多人以為執行 <code>simple call</code> 是如下圖圈選的概念 <code>window.count</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-8.png\"><br>所以他會調用全域的 <code>window</code><br>但是 <code>simple call</code> 的概念並非是在 <code>window</code> 底下執行這個函式，並不是執行函式的概念<br>像是下圖 11 行的立即函式裡面 <code>test()</code> 並不是屬於全域下的變數<br>所以 <code>window.test()</code> 並沒有辦法直接去執行</p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-9.png\"></p>\n<blockquote>\n<p>簡單來說若是看到一個函式，他是直接執行，他就屬於 <code>simple call</code><br>但是他不是在全域的物件下去執行一個函式</p>\n</blockquote>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"this 調用方式 (2)","url":"/blog/2020/10/31/this3/","content":"<p><code>this</code> 調用方式：<br>「<code>bind</code>、<code>apply</code>、<code>call</code> 方法」內容</p>\n<a id=\"more\"></a>\n<p>現在先定義另外一個函式，裡面帶兩個參數，並使用 <code>console</code> 來顯示 <code>this</code><br>以及「參數 1 」、「參數 2」</p>\n<p>「<code>bind</code>、<code>apply</code>、<code>call</code>」這三個方法觀念相近，只是呼叫方式會有點不同<br>在此會先介紹這三個方法的呼叫方式，以及他跟 <code>this</code> 的關係<br>這三個都會影響函式的呼叫方式，只不過在運作方面會有些許的不同</p>\n<p>首先執行函式會如下圖 <code>count ()</code> 接下來帶「參數 1 」、「參數 2」<br>接下來就可執行這段函式，這種方式是屬於 <code>simple call</code><br>因此 <code>this</code> 會調用全域的物件，因此 <code>this</code> 是全域的 <code>window</code><br>接著後面也帶「參數 1 」、「參數 2」</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num = 10;</span><br><span class=\"line\"><span class=\"keyword\">function</span> count(a, b) &#123;</span><br><span class=\"line\">  console.log(this);</span><br><span class=\"line\">  console.log(a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count(10, 20);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-10.png\"></p>\n<h2 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call\"></a>Call</h2><p>接著改用 <code>call</code> 的方式來執行這段函式<br>使用 <code>count.call</code> 接著第一個帶入的是 <code>this</code> 的物件<br>把 <code>item</code> 給帶進去，接著帶入 10 和 20<br>可參考 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call\">MDN 文件</a></p>\n<p>現在是使用 <code>call</code> 方式執行時，第一個參數是 <code>this</code> ，後面的參數就會以函式本身的參數依序帶入，所以第 2 行的 <code>item</code> 會替代掉原本這個函式的 <code>this</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num = 10</span><br><span class=\"line\">var item = &#123;</span><br><span class=\"line\">  num: 100</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> count(a, b) &#123;</span><br><span class=\"line\">  console.log(this,a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count.call(item,10, 20);</span><br></pre></td></tr></table></figure>\n<p>可看到下圖目前執行的結果<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-11.png\"></p>\n<p>原本全域的 <code>window</code> 就會被替換成 <code>item</code> 這個物件，因此 <code>num</code> 就是 100<br>後面帶上 10 跟 20 的數字</p>\n<p>當我們在使用 <code>call</code> 要注意，他是立刻執行，跟我們一般呼叫函式是非常接近<br>只不過他可透過這種方式將 <code>this</code> 給替換掉</p>\n<h2 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h2><p><code>apply</code> 也是類似的觀念，後方也一樣可帶入 <code>this</code><br>在此與 <code>call</code> 就有不同點<br><code>call</code> 是將參數依序帶入，<code>apply</code> 是將參數以陣列呈現，如下圖結果<br>這兩者運用上是非常接近的，只不過在調用參數有點不同</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num = 10</span><br><span class=\"line\">var item = &#123;</span><br><span class=\"line\">  num: 100</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> count(a, b) &#123;</span><br><span class=\"line\">  console.log(this,a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count.apply(item,[10, 20]);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-12.png\"></p>\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p><code>call</code> 在調用時，會立刻執行，但是 <code>bind</code> 是不會立刻執行這段函式<br>因此在用 <code>bind</code> 時候可先宣告一個變數，並且使用 <code>bind</code> 的方法<br>注意這段 <code>bind</code> (下圖圈選處) 是不會立刻執行<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-13.png\"></p>\n<p>把參數傳入的方式與 <code>call</code> 是一樣的<br>在此把 <code>item</code> 與其他內容傳入<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-14.png\"></p>\n<p>我們在去調用他的時候，他才會執行，使用 <code>temp()</code><br>接著他就會立刻去執行這段函式</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var num = 10</span><br><span class=\"line\">var item = &#123;</span><br><span class=\"line\">  num: 100</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> count(a, b) &#123;</span><br><span class=\"line\">  console.log(this,a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var temp = count.bind(item,10, 20);</span><br><span class=\"line\">temp();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-15.png\"></p>\n<p>下圖這段程式在調用時，他就會自動把 <code>this</code> 給替換掉，並且把「10」「20」也一起傳進去</p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-16.png\"></p>\n<p>在執行 <code>temp()</code> 時候，這個參數就不用另外帶入，如果在這個階段想要另外帶入參數是否可行，如下圖，把參數另外帶進去是不會有任何變化的</p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-17.png\"></p>\n<p>在使用 <code>bind</code> 時候就會強制把參數寫進去<br>在寫入參數時候也可以使用部分寫入的方式，也就是 <code>bind</code> 的地方<br>第一個參數是寫「10」，但第二個參數先不要帶入</p>\n<p>結果如下，第一個參數是「10」，第二個是 <code>temp()</code> 執行的第一個參數<br>也就是他一樣會依序執行</p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-18.png\"></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"JavaScript 算術運算子","url":"/blog/2020/10/29/JavaScript-%E7%AE%97%E8%A1%93%E9%81%8B%E7%AE%97%E5%AD%90/","content":"<p>紀錄 <code>JavaScript 算術運算子</code>內容</p>\n<a id=\"more\"></a>\n<h2 id=\"加號\"><a href=\"#加號\" class=\"headerlink\" title=\"加號 (+)\"></a>加號 (+)</h2><p>若兩者都為 <code>Number</code> 則如同一般運算方式</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var total = 10 + 10; // 20</span><br></pre></td></tr></table></figure>\n<p>假若其中一項為字串，則相加結果會變成字串<br>也就是說，其中一項是字串，另一項會被「自動轉型」為字串後連在一起</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var total = 10 + <span class=\"string\">&#x27;10&#x27;</span>; // 1010</span><br></pre></td></tr></table></figure>\n<p>若改為如下則結果還是字串內容<br>因為運算式的計算是「由左而右」且「先乘除後加減」的模式來運算。<br>所以前面的字串會先與 <code>a</code> 相加，再把結果與 <code>b</code> 做相加。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 5;</span><br><span class=\"line\">var b = 5;</span><br><span class=\"line\">var total = <span class=\"string\">&quot;5 加 5 等於 &quot;</span> + a + b; // 5 加 5 等於 55</span><br></pre></td></tr></table></figure>\n<p>為避免這樣的情況，需要用小括號包起 <code>a + b</code> 就可以得到正確的結果</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 5;</span><br><span class=\"line\">var b = 5;</span><br><span class=\"line\">var total = <span class=\"string\">&quot;5 加 5 等於 &quot;</span> + (a + b); // 5 加 5 等於 10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"減號\"><a href=\"#減號\" class=\"headerlink\" title=\"減號 (-)\"></a>減號 (-)</h2><p>與加號不同，其中一項為字串時會先將數值轉為「數字」，再進行減法運算。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var total = 50 - <span class=\"string\">&#x27;10&#x27;</span>; // 40</span><br></pre></td></tr></table></figure>\n<p>但如果碰到 <code>boolean</code> 也會轉型為「數字」，再進行運算。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">100 - <span class=\"literal\">true</span> // 99</span><br><span class=\"line\">100 - <span class=\"literal\">false</span> //100</span><br></pre></td></tr></table></figure>\n<p>也就是做減法運算時，若其中一方屬於基本型別且不是數字的情況，那麼 <code>JavaScript</code> 會在先在背後透過 <code>Number()</code> 嘗試將數值轉為「數字」，再進行運算。</p>\n<h2 id=\"乘號\"><a href=\"#乘號\" class=\"headerlink\" title=\"乘號 (*)\"></a>乘號 (*)</h2><p>乘號在碰到其中一項不是 <code>Number</code> 的話，那麼 <code>JavaScript</code> 就會先在背後以 <code>Nubmer()</code> 作轉換後再進行計算</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">100 * <span class=\"string\">&quot;10&quot;</span>      // 1000</span><br><span class=\"line\">100 * abc       // NaN</span><br><span class=\"line\"></span><br><span class=\"line\">100 * <span class=\"literal\">true</span>      // 100</span><br><span class=\"line\">100 * <span class=\"literal\">false</span>     // 0</span><br><span class=\"line\"></span><br><span class=\"line\">100 * &#123;&#125;        // NaN</span><br></pre></td></tr></table></figure>\n<h2 id=\"除號\"><a href=\"#除號\" class=\"headerlink\" title=\"除號 (/)\"></a>除號 (/)</h2><p>除法與乘法的規則類似。<br>也都是碰到其中一項不是 <code>Number</code> 的話就轉型為 <code>Number</code> 再進行運算<br>但是，在除數為 <code>0</code> 的情況下：</p>\n<p>被除數為正數，則結果為 <code>Infinity</code><br>被除數為負數，則結果為 <code>-Infinity</code><br>被除數為 <code>0</code>，則結果為 <code>NaN</code><br>當然，如果有其中一個是 <code>NaN</code>，則結果也會是 <code>NaN</code> 。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">100 / 0      // Infinity</span><br><span class=\"line\">-100 / 0     // -Infinity</span><br><span class=\"line\">0 / 0        // NaN</span><br><span class=\"line\">NaN / 0      // NaN</span><br></pre></td></tr></table></figure>\n\n<p>以上內容均參考<a href=\"https://ithelp.ithome.com.tw/articles/10191180\">重新認識 JavaScript: Day 06 運算式與運算子</a></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"this 調用方式 (3)","url":"/blog/2020/10/31/this4/","content":"<p><code>this</code> 調用方式：<br>「<code>new</code>」和「<code>DOM</code> 事件處理器」內容</p>\n<a id=\"more\"></a>\n<h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\">MDN 文件</a>提到 <code>new 運算子</code>會產生一個新的空白物件，並且連結原本的建構物件，如下面範例的 <code>bottle function</code><br>並且把新產生物件的 <code>this</code> 綁定到這個函式之上<br>所以在這建構函式所使用的 <code>this</code> 就會綁定到新物件上面</p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-19.png\"></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> bottle (name,color,size) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.color = color;</span><br><span class=\"line\">  this.size = size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var drinkbottle = new bottle(<span class=\"string\">&#x27;寶特瓶&#x27;</span>, <span class=\"string\">&#x27;藍色&#x27;</span>,<span class=\"string\">&#x27;500 ml&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-20.png\"></p>\n<h2 id=\"DOM-事件處理器\"><a href=\"#DOM-事件處理器\" class=\"headerlink\" title=\"DOM 事件處理器\"></a>DOM 事件處理器</h2><p>這邊主要介紹操作 <code>DOM</code> 元素 <code>this</code> 會有甚麼不同，主要有兩個部分</p>\n<h3 id=\"把方法寫在元素上面\"><a href=\"#把方法寫在元素上面\" class=\"headerlink\" title=\"把方法寫在元素上面\"></a>把方法寫在元素上面</h3><p>如下圖使用 <code>console.dir</code>，顯示結果為單純的物件<br>就可了解 <code>this</code> 會直接綁定在這個元素<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-21.png\"></p>\n<h3 id=\"監聽器\"><a href=\"#監聽器\" class=\"headerlink\" title=\"監聽器\"></a>監聽器</h3><p>使用 <code>querySelectorAll</code> 把所有的 <code>BUTTON</code> 取出來，並且為所有的 <code>BUTTON</code> 補上監聽器<br>監聽的方法是 <code>click</code> ，所以點所有的 <code>BUTTON</code> 都會觸發事件，觸發的時候會執行 <code>fn()</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button&gt;1&lt;/button&gt;</span><br><span class=\"line\">&lt;button&gt;2&lt;/button&gt;</span><br><span class=\"line\">&lt;button&gt;3&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">var fn = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  console.dir(this);</span><br><span class=\"line\">  this.style.color = <span class=\"string\">&#x27;green&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var els = document.querySelectorAll(<span class=\"string\">&#x27;button&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (var i=0; i&lt;els.length; i++) &#123;</span><br><span class=\"line\">  els[i].addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, fn, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-22.png\"></p>\n<p>點 <code>BUTTON</code> 下方會出現 <code>DOM 物件</code> 點開來看就可看到相關的屬性<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-23.png\"></p>\n<p>第 3 行 <code>this</code> </p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">this.style.color = <span class=\"string\">&#x27;green&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p>也會受到第 7 行監聽器影響</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">els[i].addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, fn, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>讓這個 <code>this</code> 指向我們所點擊的物件<br>這也有助於開發上可正確取得我們所點擊的物件</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"this 調用方式 (4) 和 Vue.js 的 this","url":"/blog/2020/10/31/this5/","content":"<p><code>this</code> 調用方式：「箭頭函式 (<code>ES6</code>)」內容<br>以及 <code>Vue.js</code> 的 <code>this</code> 指向</p>\n<a id=\"more\"></a>\n<h2 id=\"箭頭函式-ES6\"><a href=\"#箭頭函式-ES6\" class=\"headerlink\" title=\"箭頭函式 (ES6)\"></a>箭頭函式 (ES6)</h2><p>箭頭函式有以下幾個特點：</p>\n<h3 id=\"箭頭函式與傳統函式最大不同處是在-this-綁定是不一樣的\"><a href=\"#箭頭函式與傳統函式最大不同處是在-this-綁定是不一樣的\" class=\"headerlink\" title=\"箭頭函式與傳統函式最大不同處是在 this 綁定是不一樣的\"></a>箭頭函式與傳統函式最大不同處是在 this 綁定是不一樣的</h3><ol>\n<li>範例 1<br>「箭頭函式」是沒有自己的 <code>this</code>，如下方範例</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">  item:<span class=\"string\">&#x27;杯子&#x27;</span>,</span><br><span class=\"line\">  num: () =&gt; &#123;</span><br><span class=\"line\">    console.log(this)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data.num();</span><br></pre></td></tr></table></figure>\n<p><code>num</code> 用「箭頭函式」則會指向 <code>Window</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-28.png\"></p>\n<p>改用「傳統函式」就可以正確指向 <code>data</code> 物件<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-29.png\"></p>\n<ol start=\"2\">\n<li>範例 2<br><code>setTimeout</code> 是屬於簡易呼叫，簡易呼叫的情況下， <code>this</code> 就會指向 <code>window</code><br>若用「傳統函式」則會指向 <code>Window</code> </li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">  item:<span class=\"string\">&#x27;杯子&#x27;</span>,</span><br><span class=\"line\">  num: <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">      console.log(this)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data.num();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-30.png\"></p>\n<p>但若改用「箭頭函式」則會指向 <code>data</code> 物件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var data = &#123;</span><br><span class=\"line\">  item:<span class=\"string\">&#x27;杯子&#x27;</span>,</span><br><span class=\"line\">  num: <span class=\"function\"><span class=\"title\">function</span></span>() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt;&#123;</span><br><span class=\"line\">      console.log(this)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">data.num();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-31.png\"></p>\n<blockquote>\n<p>所以當看到「箭頭函式」裡面有 <code>this</code> 時候，可以先當「箭頭函式」不存在，這個 <code>this</code> 就用外層他作用域的 <code>this</code></p>\n</blockquote>\n<h3 id=\"this-不同，導致-DOM-的-this-也會指向不同位置\"><a href=\"#this-不同，導致-DOM-的-this-也會指向不同位置\" class=\"headerlink\" title=\"this 不同，導致 DOM 的 this 也會指向不同位置\"></a>this 不同，導致 DOM 的 this 也會指向不同位置</h3><p>這邊要注意，因為箭頭函式的 <code>this</code> 指向位置是不一樣的，所以使用 <code>this</code> 要注意使用的是「傳統函式」還是「箭頭函式」，下方範例是透過 <code>click</code> 方式把 <code>DOM</code> 位置給取出</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;項目 1&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var el = document.querySelector(<span class=\"string\">&#x27;p&#x27;</span>);</span><br><span class=\"line\">el.addEventListener(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"title\">function</span></span>()&#123;</span><br><span class=\"line\">  console.log(this)</span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n\n<p>點擊畫面的文字內容後，<code>console</code> 就顯示點擊的位置<br>也就是 <code>console.log(this)</code> 指的是 <code>el</code> 這個 <code>DOM 元素</code></p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-32.png\"></p>\n<p>改為「箭頭函式」，存檔後一樣點文字，會發現他指向 <code>Window</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-33.png\"></p>\n<p>因為「箭頭函式」沒有屬於他自己的 <code>this</code> 所以改為「箭頭函式」，他的 <code>this</code> 就會指向全域<br>也因為「箭頭函式」沒有自己的 <code>this</code> 當然也無法透過 <code>call</code>、<code>apply</code>、<code>bind</code> 的方式重新給予 <code>this</code><br>此為「箭頭函式」指向是不一樣的，所以也無法作為建構函式使用</p>\n<h2 id=\"Vue-js-this-的指向\"><a href=\"#Vue-js-this-的指向\" class=\"headerlink\" title=\"Vue.js this 的指向\"></a>Vue.js this 的指向</h2><p>如同六角學院講師 卡斯伯所寫的<a href=\"https://wcc723.github.io/javascript/2019/03/18/JS-THIS/\">文章</a>提到：</p>\n<blockquote>\n<p><code>Vue</code> 實際運作時，元件內的物件、函式等等均會被向上拉，<code>methods</code>, <code>computed</code> 等等均不會存在，所以並非以原始碼而是以實際運行的狀態為主<br><code>methods</code> 內的 <code>function</code> 及 <code>data</code> 內的內容均在元件物件頂層。<br>元件下的函式的 <code>this</code> 就會直接指向該元件，所以 <code>methods</code> 內的 <code>function</code> 的 <code>this</code> 自然就能夠使用元件內的 <code>text</code> 資料。</p>\n</blockquote>\n<p>但若是 <code>method</code> 或是 <code>computed</code> 裡面的 <code>function</code> 有使用其他 <code>function</code> 需注意 <code>this</code> 指向</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">&quot;app&quot;</span>&gt;</span><br><span class=\"line\">  &lt;div v-for=<span class=\"string\">&quot; item in filterArray&quot;</span>&gt; &#123;&#123;item.name&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">var app = new Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&#x27;#app&#x27;</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    arrayData: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        name: <span class=\"string\">&#x27;小明&#x27;</span>,</span><br><span class=\"line\">        age: 16</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        name: <span class=\"string\">&#x27;漂亮阿姨&#x27;</span>,</span><br><span class=\"line\">        age: 24</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        name: <span class=\"string\">&#x27;杰倫&#x27;</span>,</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    filterText: <span class=\"string\">&#x27;杰倫&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    filterArray: <span class=\"function\"><span class=\"title\">function</span></span> ()&#123;</span><br><span class=\"line\">      <span class=\"comment\"># var vm = this;</span></span><br><span class=\"line\">      <span class=\"built_in\">return</span> this.arrayData.filter(<span class=\"keyword\">function</span>(item)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">return</span> item.name.match(this.filterText)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>結果如圖<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-24.png\"></p>\n<p>這是因為原本的 <code>this</code> 指的是 <code>Vue</code> 這個物件，在經過 <code>filter</code> 後，此時的 <code>this</code> 已<br>經不是一開始的 <code>this</code>，而是 <code>Window</code> </p>\n<p>如下圖在 <code>filter</code> 用 <code>console.log(this)</code> 就可看到指向 <code>Window</code></p>\n<p><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-26.png\"></p>\n<p>若改用 <code>console.log(vm)</code> 則指向 <code>Vue</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-27.png\"></p>\n<p>而且也能正確顯示資料<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-25.png\"></p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML","Vue"]},{"title":"localStorage","url":"/blog/2020/10/23/localStorage/","content":"<p><code>localStorage</code> 若用「.」取值會出現以下狀況</p>\n<a id=\"more\"></a>\n<p>在 <a href=\"https://stackoverflow.com/a/24904863\">stackoverflow 討論</a>有提到若是 <code>localStorage</code> 用「.」來儲存一個屬性叫做 <code>length</code> 名稱<br>也就是與查詢長度是一樣名稱，導致他以為是要設定 <code>localStorage</code> 的長度為 <code>foo</code><br>造成語法錯誤，所以用 <code>console.log(localStorage.length)</code> 會顯示長度為 <code>0</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">localStorage.length = <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\">console.log(localStorage.length) // =&gt; 0</span><br></pre></td></tr></table></figure>\n<p>因此若要取得 <code>localStorage</code> 的值建議還是用 <code>getItem</code> 語法</p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"UNIX timestamp 整理","url":"/blog/2020/10/28/timestamp/","content":"<p>整理日期轉換的方式</p>\n<a id=\"more\"></a>\n<h2 id=\"取得日期時間\"><a href=\"#取得日期時間\" class=\"headerlink\" title=\"取得日期時間\"></a>取得日期時間</h2><p>在 <code>JavaScript</code> 若要取得時間可用 <code>new Date()</code><br>而若要瞭解完整時間可輸入下列程式碼</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var time = new Date()</span><br><span class=\"line\">time.getFullYear()</span><br><span class=\"line\">time.getMonth()               //    回傳數值，取得該日的月份，月份 0 表示 1 月！</span><br><span class=\"line\">time.getDate()                //    回傳數值，取得該日為該月份的幾號</span><br><span class=\"line\">time.getDay()                 //    回傳數值，取得該日為星期幾</span><br><span class=\"line\">time.getSeconds()             //    回傳數值，取得日期物件的秒資訊</span><br><span class=\"line\">time.getMinutes()             //    回傳數值，取得日期物件的分資訊分</span><br><span class=\"line\">time.getHours()               //    回傳數值，取得日期物件的小時資訊</span><br></pre></td></tr></table></figure>\n<h2 id=\"UNIX-timestamp-簡介\"><a href=\"#UNIX-timestamp-簡介\" class=\"headerlink\" title=\"UNIX timestamp 簡介\"></a>UNIX timestamp 簡介</h2><p>但因為全球因為有時區問題，所以需要共通自訂時間，稱為 <code>UNIX 時間</code><br>從 1970 年 1 月 1 日 0 時 0 分 0 秒起至現在的總秒數，不考慮閏秒。<br>下面的語法是取得總毫秒，但一般的 <code>UNIX timestamp</code> 通常是以秒數為單位<br>可參考<a href=\"https://stackoverflow.com/a/4676213\">stackoverflow 討論</a></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date.now() //  回傳當前的 timestamp（毫秒）</span><br></pre></td></tr></table></figure>\n<p>或是</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var time = new Date()</span><br><span class=\"line\">time.getTime()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取得某個時間\"><a href=\"#取得某個時間\" class=\"headerlink\" title=\"取得某個時間\"></a>取得某個時間</h2><p>如果想知道某年月日時間資訊可輸入</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date(<span class=\"string\">&#x27;年/月/日&#x27;</span>)</span><br><span class=\"line\">time.getTime()</span><br></pre></td></tr></table></figure>\n<p>或是</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date(<span class=\"string\">&#x27;年-月-日&#x27;</span>) //舊瀏覽器可能不支援</span><br></pre></td></tr></table></figure>\n<p>得到結果如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date(<span class=\"string\">&#x27;2020/1/1&#x27;</span>)</span><br><span class=\"line\">Wed Jan 01 2020 00:00:00 GMT+0800 (台北標準時間)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UNIX-timestamp-轉換當下時間\"><a href=\"#UNIX-timestamp-轉換當下時間\" class=\"headerlink\" title=\"UNIX timestamp 轉換當下時間\"></a>UNIX timestamp 轉換當下時間</h2><p>也可以把 <code>UNIX timestamp</code> 秒數轉換當下時間，方法如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date (UNIX 秒數)</span><br></pre></td></tr></table></figure>\n<p>結果如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date(1516008367167) //傳入毫秒</span><br><span class=\"line\">// Mon Jan 15 2018 17:26:07 GMT+0800 ( 台北標準時間 )</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UNIX-timestamp-轉換\"><a href=\"#UNIX-timestamp-轉換\" class=\"headerlink\" title=\"UNIX timestamp 轉換\"></a>UNIX timestamp 轉換</h2><h3 id=\"轉換日期\"><a href=\"#轉換日期\" class=\"headerlink\" title=\"轉換日期\"></a>轉換日期</h3><p>但因為一般 <code>timestamp</code> 取得的是秒數，但在 <code>JavaScript</code> 中要帶入的是毫秒<br>所以要 <code>new Date(timestamp * 1000)</code>：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 1513598707 為 timestamp</span><br><span class=\"line\">new Date(1513598707*1000)          // 因為一般 timestamp 取得的是秒數，但要帶入的是毫秒，所以要乘 1000</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者</span><br><span class=\"line\">var date = new Date(timestamp * 1000)</span><br><span class=\"line\">dataValues = [</span><br><span class=\"line\">   date.getFullYear(),</span><br><span class=\"line\">   date.getMonth()+1,</span><br><span class=\"line\">   date.getDate(),</span><br><span class=\"line\">   date.getHours(),</span><br><span class=\"line\">   date.getMinutes(),</span><br><span class=\"line\">   date.getSeconds(),</span><br><span class=\"line\">];</span><br><span class=\"line\">console.log(dataValues);</span><br></pre></td></tr></table></figure>\n<h3 id=\"轉換-timestamp\"><a href=\"#轉換-timestamp\" class=\"headerlink\" title=\"轉換 timestamp\"></a>轉換 timestamp</h3><p>同樣的要取得 <code>timestamp</code> ，也就是總秒數則除以 1000</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var dateTime = Date.now();</span><br><span class=\"line\">var timestamp = Math.floor(dateTime / 1000);</span><br></pre></td></tr></table></figure>\n<p>或是</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var dateTime = new Date().getTime();</span><br><span class=\"line\">var timestamp = Math.floor(dateTime / 1000);</span><br></pre></td></tr></table></figure>\n<h2 id=\"轉換成常見日期格式\"><a href=\"#轉換成常見日期格式\" class=\"headerlink\" title=\"轉換成常見日期格式\"></a>轉換成常見日期格式</h2><p>若要把之前取得的日期，如下</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Mon Dec 18 2017 20:05:07 GMT+0800 (台北標準時間)</span><br></pre></td></tr></table></figure>\n<p>改為 2017-12-18 這樣的格式<br>就要改為 ISO 8601 標準時間格式<br>可以使用 <code>Date.prototype.toISOString()</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = new Date(<span class=\"string\">&#x27;Mon Dec 18 2017 20:05:07 GMT+0800 (台北標準時間)&#x27;</span>)</span><br><span class=\"line\">a.toISOString()</span><br></pre></td></tr></table></figure>\n<p>他會回傳下方內容</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">2017-12-18T12:05:07.000Z</span><br></pre></td></tr></table></figure>\n<p>接著可用 <code>split()</code> 來分割日期和時間內容</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">a.toISOString().split(<span class=\"string\">&#x27;T&#x27;</span>)</span><br><span class=\"line\">// 回傳陣列結果 [<span class=\"string\">&quot;2017-12-18&quot;</span>, <span class=\"string\">&quot;12:05:07.000Z&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>若只要取得日期就可用</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">a.toISOString().split(<span class=\"string\">&#x27;T&#x27;</span>)[0]</span><br><span class=\"line\">//  [<span class=\"string\">&quot;2017-12-18&quot;</span>]</span><br></pre></td></tr></table></figure>\n<p>以上可參考 <a href=\"https://codepen.io/HexSchool_yuko/pen/VwwvZzG\">Codepen 範例</a><br>上述內容也參考下方文章<br><a href=\"https://pjchender.github.io/2017/12/27/js-javascript-date-time-method-%E6%97%A5%E6%9C%9F%E6%99%82%E9%96%93/\">JavaScript Date Time Method 日期時間</a><br><a href=\"https://www.jstips.co/zh_tw/javascript/extract-unix-timestamp-easily/\">在 JavaScript 簡單取得 unix timestamp</a></p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"物件取值、新增、刪除","url":"/blog/2020/09/21/%E7%89%A9%E4%BB%B6%E5%8F%96%E5%80%BC%E3%80%81%E6%96%B0%E5%A2%9E%E3%80%81%E5%88%AA%E9%99%A4/","content":"<p>這邊紀錄物件取值和新增、刪除用法</p>\n<a id=\"more\"></a>\n<h2 id=\"物件取值\"><a href=\"#物件取值\" class=\"headerlink\" title=\"物件取值\"></a>物件取值</h2><p>物件取值有兩種方法，一個是用「.」，另一個是用 <code>[ ]</code><br>1.使用「.」來取值</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  item:10</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(a.item);//10</span><br></pre></td></tr></table></figure>\n<p>2.使用 <code>[ ]</code>，在物件變數後面加上 [ ] 裡面插入要取得值的字串</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  item:10</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(a[<span class=\"string\">&#x27;item&#x27;</span>]);//10</span><br></pre></td></tr></table></figure>\n<p>使用 <code>[ ]</code> 不僅可用字串取值，他還可用變數的方式來取值</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  item:100</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var b = <span class=\"string\">&#x27;item&#x27;</span>;</span><br><span class=\"line\">console.log(a[b]); //100</span><br></pre></td></tr></table></figure>\n<p>陣列也屬於物件型別的其中一種<br>陣列取值若遇到小數點、中文或是特殊字元<br>可用 <code>[ ]</code> 來取值，像是 <code>PM2.5</code> 建議改用 <code>[&quot;PM2.5&quot;]</code><br><code>data[i][&quot;PM2.5&quot;]</code><br><code>data[i][&quot;縣市&quot;]</code></p>\n<h2 id=\"新增\"><a href=\"#新增\" class=\"headerlink\" title=\"新增\"></a>新增</h2><p>與取值一樣，用「.」也可用 <code>[ ]</code> 來增加屬性</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  item: <span class=\"string\">&#x27;項目 1&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.title = <span class=\"string\">&#x27;標題 a&#x27;</span>;</span><br><span class=\"line\">a[<span class=\"string\">&#x27;num&#x27;</span>] = 100;</span><br><span class=\"line\">console.log(a);</span><br><span class=\"line\">//Object &#123;</span><br><span class=\"line\">  item: <span class=\"string\">&quot;項目 1&quot;</span>,</span><br><span class=\"line\">  num: 100,</span><br><span class=\"line\">  title: <span class=\"string\">&quot;標題 a&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"刪除\"><a href=\"#刪除\" class=\"headerlink\" title=\"刪除\"></a>刪除</h2><p>可用 <code>delete</code> 這個操作符並用「.」接著後方加入物件名稱和屬性名稱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  item: <span class=\"string\">&#x27;項目 1&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.title = <span class=\"string\">&#x27;標題 a&#x27;</span>;</span><br><span class=\"line\">a[<span class=\"string\">&#x27;num&#x27;</span>] = 100;</span><br><span class=\"line\">delete a.item;</span><br><span class=\"line\">console.log(a);</span><br><span class=\"line\">//Object &#123;</span><br><span class=\"line\">  num: 100,</span><br><span class=\"line\">  title: <span class=\"string\">&quot;標題 a&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可用 <code>[ ]</code> 來刪除</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  item: <span class=\"string\">&#x27;項目 1&#x27;</span>,</span><br><span class=\"line\">  item2: <span class=\"string\">&#x27;項目 2&#x27;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.title = <span class=\"string\">&#x27;標題 a&#x27;</span>;</span><br><span class=\"line\">a[<span class=\"string\">&#x27;num&#x27;</span>] = 100;</span><br><span class=\"line\">delete a[<span class=\"string\">&#x27;item2&#x27;</span>];</span><br><span class=\"line\">console.log(a);</span><br><span class=\"line\">//Object &#123;</span><br><span class=\"line\">  item: <span class=\"string\">&quot;項目 1&quot;</span>,</span><br><span class=\"line\">  num: 100,</span><br><span class=\"line\">  title: <span class=\"string\">&quot;標題 a&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"陣列為空的判斷","url":"/blog/2020/10/22/%E9%99%A3%E5%88%97%E7%82%BA%E7%A9%BA%E7%9A%84%E5%88%A4%E6%96%B7/","content":"<p>在判斷陣列為空時，會出現以下的問題點</p>\n<a id=\"more\"></a>\n<p>在做陣列為空的判斷，可能會有以下的寫法</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [];</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a == []) &#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">&#x27;空的&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但實際去運作時，卻沒任何反應，這是因為陣列屬於物件的型別<br>物件的型別在比對時都是比對他們的參考位置<br><code>a</code> 和 <code>[]</code> 去比對時，實際上是兩個參考位置是不一樣的，如下面的<br><code>a == []</code> 結果是 <code>false</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">console.log(a == []); //<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>所以用 if 判斷結果是 false 自然是不會顯示內容<br>因此判斷資料長度建議是用 length</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [];</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a.length == 0) &#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">&#x27;空的&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"按鈕 type 設定","url":"/blog/2020/10/25/%E6%8C%89%E9%88%95-type-%E8%A8%AD%E5%AE%9A/","content":"<p>紀錄按鈕的 <code>type</code> 會出現的狀況</p>\n<a id=\"more\"></a>\n\n<p><code>type = &quot;submit&quot;</code> 類型會被視為提交按鈕，點選的話就透過 <code>action</code> 把表單提交到伺服器。<br>在 <code>HTML</code> 裡面的 <code>form action</code> 如果有寫上 <code>index.html</code><br>是指提交資料送出到 <code>index.html</code> 如果沒有這個網頁就可能會出錯<br>一般來說都會讓 <code>form action</code> 空著，有需求才寫送出的位址。<br><code>type = &quot;button&quot;</code> 表示這是按鈕，並不會將表單提交出去到伺服器。<br>或者是加上 <code>preventDefault()</code> 也可以取消預設行為</p>\n<p>以下為參考文件<br><a href=\"http://www.w3school.com.cn/tags/att_form_action.asp\">W3school 對 form action 的解釋</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/input/submit\">MDN 解釋 type 類型 submit</a></p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"this 簡介","url":"/blog/2020/10/31/this/","content":"<p><code>this</code> 觀念整理</p>\n<a id=\"more\"></a>\n<h2 id=\"this-簡介\"><a href=\"#this-簡介\" class=\"headerlink\" title=\"this 簡介\"></a>this 簡介</h2><p>不管是在全域的環境下，或是在特定的函式，都可調用 <code>this</code> 這個關鍵字<br>那麼 <code>this</code> 因為在每個執行環境都存在，所以 <code>this</code> 很容易被誤認為指向函式<br>函式本身這個物件所能提供的屬性非常有限，通常來說不會使用函式調用 <code>this</code> 本身<br><code>this</code>  通常是指向可以被運用的物件，所以不要誤認為函式中的 <code>this</code> 就指向該函式</p>\n<p><code>this</code> 是在執行函式時候就自然產生，不需要去宣告他，他是個關鍵字<br>如下圖 <code>Chrome</code> 的 <code>Source</code> 按下 <code>debug</code> 工具，按下圖中的按鈕<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-1.png\"></p>\n<p>重整之後來進入這個函式的執行堆疊<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-2.png\"><br>並連續兩次按下圖片上的按鈕<br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-3.png\"><br>接下來會發現，<code>Local</code> 會自動帶上 <code>this</code><br><img src=\"https://ruienyuski.github.io/photo/hexo_img/20201031_this/this-4.png\"><br>而這個 <code>this</code> 目前是指向 <code>window</code> 而這個 <code>this</code> 他實際指向跟我們如何去呼叫這個函式有很大的關連性</p>\n<h2 id=\"this-基本觀念\"><a href=\"#this-基本觀念\" class=\"headerlink\" title=\"this 基本觀念\"></a>this 基本觀念</h2><ul>\n<li>每個執行環境都有屬於自己的 <code>this</code> 關鍵字</li>\n<li><code>this</code> 與函式如何宣告<strong>沒有關聯性</strong>，僅與呼叫方式有關</li>\n<li><strong>嚴格模式</strong>下，簡易呼叫會有很大的改變</li>\n</ul>\n<h2 id=\"常見的調用方式\"><a href=\"#常見的調用方式\" class=\"headerlink\" title=\"常見的調用方式\"></a>常見的調用方式</h2><p><code>this</code> 的指向與怎麼呼叫他關係並不大，主要原因在怎麼去調用他<br>以下為常見的調用方式，這些調用方式就影響 <code>this</code> 的指向</p>\n<blockquote>\n<ul>\n<li>作為物件方法 (最常運用 <code>this</code> 的方法)</li>\n<li>簡易呼叫 (絕大多數的呼叫方式)</li>\n<li><code>bind</code>，<code>apply</code>，<code>call</code> 方法</li>\n<li><code>new</code></li>\n<li><code>DOM</code> 事件處理器</li>\n<li>箭頭函式 (<code>ES6</code>)</li>\n</ul>\n</blockquote>\n<p>關於 this 的文章是紀錄 <a href=\"https://www.hexschool.com/courses/js-core.html\">六角學院 JavaScrip 核心篇</a> 上課筆記內容<br>接著則繼續說明 <code>this</code> 調用方式</p>\n","categories":["JavaScript"],"tags":["JavaScript","HTML"]},{"title":"宣告變數","url":"/blog/2020/11/07/%E5%AE%A3%E5%91%8A%E8%AE%8A%E6%95%B8/","content":"<p>變數宣告與不宣告的差異</p>\n<a id=\"more\"></a>\n\n<h2 id=\"已宣告的變數與全域物件裡的屬性\"><a href=\"#已宣告的變數與全域物件裡的屬性\" class=\"headerlink\" title=\"已宣告的變數與全域物件裡的屬性\"></a>已宣告的變數與全域物件裡的屬性</h2><p><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/var\">MDN 文件</a>中提到其中差異在於，已宣告的變數是全域物件裡的一個無法變更 (non-configurable) 的屬性, 而未宣告的變數則是可變更的 (configurable)，可以嘗試刪除產生的變數，觀察其差異。</p>\n<p>在此要介紹一個觀念「變數無法被刪除，屬性才可以」<br>這邊提供範例來說明有無宣告的差別</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">b = 2;</span><br><span class=\"line\">console.log(<span class=\"string\">&quot;a&quot;</span>,delete a,<span class=\"string\">&quot;b&quot;</span>,delete b);</span><br><span class=\"line\">//<span class=\"string\">&quot;a&quot;</span> <span class=\"literal\">false</span> <span class=\"string\">&quot;b&quot;</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><code>a</code> 和 <code>b</code> 使用 <code>delete</code> 來刪除<br>結果會是有宣告的 <code>a</code> 無法被刪除，但 <code>b</code> 是被刪除的<br>這是因為 <code>b</code> 變成 <code>window</code> 底下的屬性，所以 <code>delete</code> 結果 <code>true</code><br><code>delete</code> 是刪除物件屬性的方法</p>\n<p>可參考 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Obsolete_Pages/Obsolete_Pages/Obsolete_Pages/%E6%96%B0%E7%89%A9%E4%BB%B6%E7%9A%84%E5%BB%BA%E7%AB%8B/%E5%B1%AC%E6%80%A7%E7%9A%84%E5%88%AA%E9%99%A4\">MDN 文件</a> </p>\n<p>而 <code>a</code> 是用 <code>var</code> 宣告變數的方式去新增，所以是無法被刪除的，所以會建議都要宣告變數</p>\n<h2 id=\"var-與-let-宣告\"><a href=\"#var-與-let-宣告\" class=\"headerlink\" title=\"var 與 let 宣告\"></a>var 與 let 宣告</h2><p><code>let</code> 宣告不會變成全域變數，可以參考這篇<a href=\"https://dotblogs.com.tw/jameswang/2017/04/30/155326\">【JavaScript 新手筆記】【3】變數（Variables）</a>，裡面有提到：</p>\n<blockquote>\n<p><code>var</code> 宣告變數為全域變數。反之，<code>let</code> 宣告不會變成全域變數（就算在函數外面用 <code>let</code> 宣告變數，該變數也不會是全域變數）。 </p>\n</blockquote>\n<p>他也提供範例，可了解 <code>var</code> 和 <code>let</code> 在全域的差異</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">let</span> a = 10;</span><br><span class=\"line\">var b = 100;</span><br><span class=\"line\">console.log(window.a); // undefined</span><br><span class=\"line\">console.log(window.b); // b is 100</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["JavaScript"]}]